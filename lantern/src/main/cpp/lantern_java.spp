#pragma once

#include <jni.h>
#include <set>
#include <string>
#include <unordered_map>

#include "lantern_maps.spp"
#include "lantern_log.spp"

/*
* ===================================================================================================================================================================
* API-LEVEL   VERSION   MMAP-IN   SOLUTION
* ===================================================================================================================================================================
* 21          5.0       c++           munmap all in /proc/self/maps since mmap in native
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontListParser.Config --> FontListParser.Family --> FontListParser.Font.fontName
*                                 OR /system/etc/fonts.xml
* 22          5.1       c++          munmap all in /proc/self/maps since mmap in native
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontListParser.Config --> FontListParser.Family --> FontListParser.Font.fontName
*                                 OR /system/etc/fonts.xml
* 23          6.0       c++          munmap all in /proc/self/maps since mmap in native
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontListParser.Config --> FontListParser.Family --> FontListParser.Font.fontName
*                                 OR /system/etc/fonts.xml
* -------------------------------------------------------------------------------------------------------------------------------------------------------------------
* 24          7.0       java         Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontListParser.Config --> FontListParser.Family --> FontListParser.Font.fontName
*                                 OR /system/etc/fonts.xml
* 25          7.1       java         Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontListParser.Config --> FontListParser.Family --> FontListParser.Font.fontName
*                                 OR /system/etc/fonts.xml
* 26          8.0       java         Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontConfig --> FontConfig.Family --> FontConfig.Font.getFontName()
*                                 OR /system/etc/fonts.xml
* 27          8.1       java         Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR FontListParser.parse --> FontConfig --> FontConfig.Family --> FontConfig.Font.getFontName()
*                                 OR /system/etc/fonts.xml
* -------------------------------------------------------------------------------------------------------------------------------------------------------------------
* 28          9       java           Typeface.sSystemFallbackMap --> FontFamily.mNativePtr
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR /system/etc/fonts.xml
* -------------------------------------------------------------------------------------------------------------------------------------------------------------------
* 29          10       java          android.graphics.fonts --> SystemFonts.getAvailableFonts() --> Font.getBuffer()  *** very very slow ***
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR /system/etc/fonts.xml + /product/etc/fonts_customization.xml
* 30          11       java          android.graphics.fonts --> SystemFonts.getAvailableFonts() --> Font.getBuffer() *** very very slow ***
*                                 OR Typeface.sSystemFontMap --> Typeface.native_instance
*                                 OR /system/etc/fonts.xml + /product/etc/fonts_customization.xml
* ===================================================================================================================================================================
*/

#define JAVA_EXCEPTION_CONTINUE() ; \
    if (__env->ExceptionCheck()) \
    { \
        LOG("java exception."); \
        __env->ExceptionDescribe(); \
        __env->ExceptionClear(); \
        continue; \
    }

#define JAVA_NULLPTR_CONTINUE(ptr) ; \
    if(ptr == nullptr) \
    { \
        LOG(#ptr " == nullptr."); \
        continue; \
    }

#define JAVA_CHECK_CONTINUE(ptr) \
    JAVA_EXCEPTION_CONTINUE() \
    if(ptr == nullptr) \
    { \
        LOG(#ptr " == nullptr."); \
        continue; \
    }

#define JAVA_EXCEPTION_RETURN() ;\
    if (__env->ExceptionCheck()) \
    { \
        LOG("java exception."); \
        return; \
    }

#define JAVA_CHECK_RETURN(ptr) ; \
    if (__env->ExceptionCheck() || ptr == nullptr) \
    { \
        LOG("java exception or " #ptr " == nullptr."); \
        return; \
    }

struct javaExceptionGuard
{
    javaExceptionGuard(JNIEnv* __env)
        : jniEnv(__env) { }

    ~javaExceptionGuard()
    {
        exception();
    }

    void exception()
    {
        if (jniEnv->ExceptionCheck())
        {
            jniEnv->ExceptionDescribe();
            jniEnv->ExceptionClear();
        }
    }

    JNIEnv* jniEnv;
};

static void get_xmlnames_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::unordered_map<std::string, std::string>& __fonts)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass file_clazz = __env->FindClass("java/io/File")JAVA_CHECK_RETURN(file_clazz);
    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);

    jmethodID getAbsolutePath_methodID = __env->GetMethodID(file_clazz, "getAbsolutePath", "()Ljava/lang/String;")JAVA_CHECK_RETURN(getAbsolutePath_methodID);
    jmethodID getSystemFontConfigLocation_methodID = __env->GetStaticMethodID(typeface_clazz, "getSystemFontConfigLocation", "()Ljava/io/File;")JAVA_CHECK_RETURN(getSystemFontConfigLocation_methodID);

    jobject systemFontConfigLocation = __env->CallStaticObjectMethod(typeface_clazz, getSystemFontConfigLocation_methodID)JAVA_CHECK_RETURN(systemFontConfigLocation);

    jstring path_string = static_cast<jstring>(__env->CallObjectMethod(systemFontConfigLocation, getAbsolutePath_methodID))JAVA_CHECK_RETURN(path_string);

    const char* path = __env->GetStringUTFChars(path_string, 0)JAVA_CHECK_RETURN(path);

    if (strlen(path) > 0)
    {
        for (auto&& iter : fields)
        {
            LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

            jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_RETURN(fieldID);

            jstring xml_string = static_cast<jstring>(__env->GetStaticObjectField(typeface_clazz, fieldID))JAVA_CHECK_RETURN(xml_string);

            const char* xmlname = __env->GetStringUTFChars(xml_string, 0)JAVA_CHECK_RETURN(xmlname);

            if (strlen(xmlname) > 0)
            {
                std::string name(path);
                name.append("/");
                name.append(xmlname);

                LOG("name:%s", name.c_str());

                __fonts.emplace( name, "/system/fonts/");
            }

            __env->ReleaseStringUTFChars(xml_string, xmlname)JAVA_EXCEPTION_RETURN();

            __env->DeleteLocalRef(xml_string)JAVA_EXCEPTION_RETURN();
        }
    }

    __env->ReleaseStringUTFChars(path_string, path)JAVA_EXCEPTION_RETURN();

}

#if DEBUGGABLE
static void get_fontnames_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::set<std::string>& __names, std::function<void(std::string&)> __check_symbolic)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass file_clazz = __env->FindClass("java/io/File")JAVA_CHECK_RETURN(file_clazz);
    jclass fileInputStream_clazz = __env->FindClass("java/io/FileInputStream")JAVA_CHECK_RETURN(fileInputStream_clazz);
    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);
    jclass fontListParser_clazz = __env->FindClass("android/graphics/FontListParser")JAVA_CHECK_RETURN(fontListParser_clazz);

    jmethodID getSystemFontConfigLocation_methodID = __env->GetStaticMethodID(typeface_clazz, "getSystemFontConfigLocation", "()Ljava/io/File;")JAVA_CHECK_RETURN(getSystemFontConfigLocation_methodID);
    jmethodID file_methodID = __env->GetMethodID(file_clazz, "<init>", "(Ljava/io/File;Ljava/lang/String;)V")JAVA_CHECK_RETURN(file_methodID);
    jmethodID fileInputStream_methodID = __env->GetMethodID(fileInputStream_clazz, "<init>", "(Ljava/io/File;)V")JAVA_CHECK_RETURN(fileInputStream_methodID);

    jobject systemFontConfigLocation = __env->CallStaticObjectMethod(typeface_clazz, getSystemFontConfigLocation_methodID)JAVA_CHECK_RETURN(systemFontConfigLocation);

    for (auto&& iter : fields)
    {
        LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

        jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_RETURN(fieldID);

        jobject field = __env->GetStaticObjectField(typeface_clazz, fieldID)JAVA_CHECK_RETURN(field);

        jobject configFilename = __env->NewObject(file_clazz, file_methodID, systemFontConfigLocation, field)JAVA_CHECK_RETURN(configFilename);

        jobject fontsIn = __env->NewObject(fileInputStream_clazz, fileInputStream_methodID, configFilename)JAVA_CHECK_RETURN(fontsIn);

        if (sdk_ver_ <= __ANDROID_API_N_MR1__)
        {
            jclass fontConfig_clazz = __env->FindClass("android/graphics/FontListParser$Config")JAVA_CHECK_RETURN(fontConfig_clazz);
            jclass family_clazz = __env->FindClass("android/graphics/FontListParser$Family")JAVA_CHECK_RETURN(family_clazz);
            jclass font_clazz = __env->FindClass("android/graphics/FontListParser$Font")JAVA_CHECK_RETURN(font_clazz);
            jclass list_clazz = __env->FindClass("java/util/List")JAVA_CHECK_RETURN(list_clazz);

            jmethodID get_methodID = __env->GetMethodID(list_clazz, "get", "(I)Ljava/lang/Object;")JAVA_CHECK_RETURN(get_methodID);
            jmethodID size_methodID = __env->GetMethodID(list_clazz, "size", "()I")JAVA_CHECK_RETURN(size_methodID);

            jmethodID parse_fieldID = __env->GetStaticMethodID(fontListParser_clazz, "parse", "(Ljava/io/InputStream;)Landroid/graphics/FontListParser$Config;")JAVA_CHECK_RETURN(parse_fieldID);
            jfieldID families_fieldID = __env->GetFieldID(fontConfig_clazz, "families", "Ljava/util/List;")JAVA_CHECK_RETURN(families_fieldID);
            jfieldID fonts_fieldID = __env->GetFieldID(family_clazz, "fonts", "Ljava/util/List;")JAVA_CHECK_RETURN(fonts_fieldID);
            jfieldID fontName_fieldID = __env->GetFieldID(font_clazz, "fontName", "Ljava/lang/String;")JAVA_CHECK_RETURN(fontName_fieldID);

            jobject fontConfig = __env->CallStaticObjectMethod(fontListParser_clazz, parse_fieldID, fontsIn)JAVA_CHECK_RETURN(fontConfig);

            jobject families = __env->GetObjectField(fontConfig, families_fieldID)JAVA_CHECK_RETURN(families);

            jint families_size = __env->CallIntMethod(families, size_methodID)JAVA_EXCEPTION_RETURN();

            for (jint i = 0; i < families_size; ++i)
            {
                jobject family = __env->CallObjectMethod(families, get_methodID, i)JAVA_CHECK_RETURN(family);

                jobject fonts = __env->GetObjectField(family, fonts_fieldID)JAVA_CHECK_RETURN(fonts);

                jint fonts_size = __env->CallIntMethod(fonts, size_methodID)JAVA_EXCEPTION_RETURN();

                for (jint j = 0; j < fonts_size; ++j)
                {
                    jobject font = __env->CallObjectMethod(fonts, get_methodID, j)JAVA_CHECK_RETURN(font);

                    jstring fontname_string = static_cast<jstring>(__env->GetObjectField(font, fontName_fieldID))JAVA_CHECK_RETURN(fontname_string);

                    const char* fontname = __env->GetStringUTFChars(fontname_string, 0)JAVA_CHECK_RETURN(fontname);

                    if (strlen(fontname) > 0)
                    {
                        std::string name(fontname);
                        __check_symbolic(name);
                        __names.emplace(name);
                    }

                    __env->ReleaseStringUTFChars(fontname_string, fontname)JAVA_EXCEPTION_RETURN();

                    __env->DeleteLocalRef(fontname_string)JAVA_EXCEPTION_RETURN();
                    __env->DeleteLocalRef(font)JAVA_EXCEPTION_RETURN();
                }
                __env->DeleteLocalRef(fonts)JAVA_EXCEPTION_RETURN();
                __env->DeleteLocalRef(family)JAVA_EXCEPTION_RETURN();
            }
            __env->DeleteLocalRef(families)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(fontConfig)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(list_clazz)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(font_clazz)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(family_clazz)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(fontConfig_clazz)JAVA_EXCEPTION_RETURN();
        }
        else if (sdk_ver_ <= __ANDROID_API_O_MR1__)
        {
            jclass fontConfig_clazz = __env->FindClass("android/text/FontConfig")JAVA_CHECK_RETURN(fontConfig_clazz);
            jclass family_clazz = __env->FindClass("android/text/FontConfig$Family")JAVA_CHECK_RETURN(family_clazz);
            jclass font_clazz = __env->FindClass("android/text/FontConfig$Font")JAVA_CHECK_RETURN(font_clazz);

            jmethodID parse_fieldID = __env->GetStaticMethodID(fontListParser_clazz, "parse", "(Ljava/io/InputStream;)Landroid/text/FontConfig;")JAVA_CHECK_RETURN(parse_fieldID);
            jmethodID getFamilies_methodID = __env->GetMethodID(fontConfig_clazz, "getFamilies", "()[Landroid/text/FontConfig$Family;")JAVA_CHECK_RETURN(getFamilies_methodID);
            jmethodID getFonts_methodID = __env->GetMethodID(family_clazz, "getFonts", "()[Landroid/text/FontConfig$Font;")JAVA_CHECK_RETURN(getFonts_methodID);
            jmethodID getFontName_methodID = __env->GetMethodID(font_clazz, "getFontName", "()Ljava/lang/String;")JAVA_CHECK_RETURN(getFontName_methodID);

            jobject fontConfig = __env->CallStaticObjectMethod(fontListParser_clazz, parse_fieldID, fontsIn)JAVA_CHECK_RETURN(fontConfig);
            jobjectArray families = static_cast<jobjectArray>(__env->CallObjectMethod(fontConfig, getFamilies_methodID))JAVA_CHECK_RETURN(families);

            jsize families_size = __env->GetArrayLength(families)JAVA_EXCEPTION_RETURN();

            for (jsize i = 0; i < families_size; ++i)
            {
                jobject family = __env->GetObjectArrayElement(families, i)JAVA_CHECK_RETURN(family);

                jobjectArray fonts = static_cast<jobjectArray>(__env->CallObjectMethod(family, getFonts_methodID))JAVA_CHECK_RETURN(fonts);

                jsize fonts_size = __env->GetArrayLength(fonts)JAVA_EXCEPTION_RETURN();

                for (jsize j = 0; j < fonts_size; ++j)
                {
                    jobject font = __env->GetObjectArrayElement(fonts, j)JAVA_CHECK_RETURN(font);

                    jstring fontname_string = static_cast<jstring>(__env->CallObjectMethod(font, getFontName_methodID))JAVA_CHECK_RETURN(fontname_string);

                    const char* fontname = __env->GetStringUTFChars(fontname_string, 0)JAVA_CHECK_RETURN(fontname);

                    if (strlen(fontname) > 0)
                    {
                        std::string name("/system/fonts/");
                        name.append(fontname);
                        __check_symbolic(name);
                        __names.emplace(name);
                    }

                    __env->ReleaseStringUTFChars(fontname_string, fontname)JAVA_EXCEPTION_RETURN();

                    __env->DeleteLocalRef(fontname_string)JAVA_EXCEPTION_RETURN();
                    __env->DeleteLocalRef(font)JAVA_EXCEPTION_RETURN();
                }

                __env->DeleteLocalRef(fonts)JAVA_EXCEPTION_RETURN();
                __env->DeleteLocalRef(family)JAVA_EXCEPTION_RETURN();
            }

            __env->DeleteLocalRef(families)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(fontConfig)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(font_clazz)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(family_clazz)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(fontConfig_clazz)JAVA_EXCEPTION_RETURN();
        }

        __env->DeleteLocalRef(fontsIn)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(configFilename)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(field)JAVA_EXCEPTION_RETURN();
    }
}
#endif

#if SPECIAL_MACHINE_ANDROID
static void get_fontxml_for_oppo_from_java(JNIEnv* __env, std::unordered_map<std::string, std::string>& __xmlfiles)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass colortypeface_clazz = __env->FindClass("android/graphics/ColorTypefaceInjector")JAVA_CHECK_RETURN(colortypeface_clazz);

    jfieldID fieldID = __env->GetStaticFieldID(colortypeface_clazz, "SECOND_FONT_CONFIG_FILE", "Ljava/lang/String;")JAVA_CHECK_RETURN(fieldID);

    jstring field = static_cast<jstring>(__env->GetStaticObjectField(colortypeface_clazz, fieldID))JAVA_CHECK_RETURN(field);

    const char* config_file = __env->GetStringUTFChars(field, 0)JAVA_CHECK_RETURN(config_file);

    if (strlen(config_file) > 0)
    {
        ACCESS_XML(config_file, SYSTEM_FONTS, __xmlfiles);
    }

    __env->ReleaseStringUTFChars(field, config_file)JAVA_EXCEPTION_RETURN();
}
#endif

#if SPECIAL_MACHINE_ANDROID
static void get_fontxml_for_lge_from_java(JNIEnv* __env, std::unordered_map<std::string, std::string>& __fonts)
{
    if (sdk_ver_ == __ANDROID_API_L__
        /*  || sdk_ver_ == __ANDROID_API_L_MR1__ */
        /* || sdk_ver_ == __ANDROID_API_M__ */) // Android 5.1、6.0 未测试
    {
        bool use_ame_xml = false;

        auto get_fontxml = [&]() {
            javaExceptionGuard exceptionGuard(__env);

            jclass config_clazz = __env->FindClass("com/lge/config/ConfigBuildFlags")JAVA_CHECK_RETURN(config_clazz);

            jfieldID capp_fonts_fieldID = __env->GetStaticFieldID(config_clazz, "CAPP_FONTS", "Z")JAVA_CHECK_RETURN(capp_fonts_fieldID);

            jboolean capp_fonts_field = __env->GetStaticBooleanField(config_clazz, capp_fonts_fieldID)JAVA_EXCEPTION_RETURN();

            if (capp_fonts_field)
            {
                ACCESS_XML(SYSTEM_ETC "fonts_lge.xml", SYSTEM_FONTS, __fonts);

                jfieldID capp_emoji_fieldID = __env->GetStaticFieldID(config_clazz, "CAPP_EMOJI", "Z")JAVA_CHECK_RETURN(capp_emoji_fieldID);

                jboolean capp_emoji_field = __env->GetStaticBooleanField(config_clazz, capp_emoji_fieldID)JAVA_EXCEPTION_RETURN();

                if (capp_emoji_field)
                {
                    char ame[92] = {0};

                    if (__system_property_get("ro.build.target_region", ame) > 0)
                    {
                        if (strcmp(ame, "AME") == 0)
                        {
                            use_ame_xml = true;
                        }
                    }
                }
            }
        };

        get_fontxml();

        if (use_ame_xml)
        {
            ACCESS_XML(SYSTEM_ETC "fonts_ame.xml", SYSTEM_FONTS, __fonts);
        }
        else
        {
            ACCESS_XML(SYSTEM_ETC "fonts.xml", SYSTEM_FONTS, __fonts);
        }
    }
    else if (sdk_ver_ == __ANDROID_API_N__
             /* || sdk_ver_ == __ANDROID_API_N_MR1__ */
             || sdk_ver_ == __ANDROID_API_O__
        /* || sdk_ver_ == __ANDROID_API_O_MR1__ */) // Android 7.1、8.1 未测试
    {
        ACCESS_XML(SYSTEM_ETC "fonts.xml", SYSTEM_FONTS, __fonts);

        auto get_fontxml = [&]() {
            javaExceptionGuard exceptionGuard(__env);

            jclass config_clazz = __env->FindClass("com/lge/config/ConfigBuildFlags")JAVA_CHECK_RETURN(config_clazz);

            jfieldID use_fonts_fieldID = __env->GetStaticFieldID(config_clazz, "USE_FONTS", "Z")JAVA_CHECK_RETURN(use_fonts_fieldID);

            jboolean use_fonts =__env->GetStaticBooleanField(config_clazz, use_fonts_fieldID)JAVA_EXCEPTION_RETURN();

            if (use_fonts)
            {
                ACCESS_XML(SYSTEM_ETC "fonts_zawgyi.xml", SYSTEM_FONTS, __fonts);
                ACCESS_XML(SYSTEM_ETC "fonts_lgz.xml", SYSTEM_FONTS, __fonts);
            }
        };

        get_fontxml();
    }
}
#endif

#if SPECIAL_MACHINE_ANDROID
static void get_fontxml_for_motorola_from_java(JNIEnv* __env, std::unordered_map<std::string, std::string>& __xmlfiles)
{
    if (sdk_ver_ == __ANDROID_API_N__ || sdk_ver_ == __ANDROID_API_N_MR1__)
    {
        ACCESS_XML(SYSTEM_ETC "fonts_base.xml", SYSTEM_FONTS, __xmlfiles);

        std::string oem_dir;

        auto get_fontxml = [&](){
            javaExceptionGuard exceptionGuard(__env);

            jclass environment_class = __env->FindClass("android/os/Environment")JAVA_CHECK_RETURN(environment_class);
            jclass file_class = __env->FindClass("java/io/File")JAVA_CHECK_RETURN(file_class);

            jmethodID getOemDirectory_methodID = __env->GetStaticMethodID(environment_class, "getOemDirectory", "()Ljava/io/File;")JAVA_CHECK_RETURN(getOemDirectory_methodID);
            jmethodID getPath_methodID = __env->GetMethodID(file_class, "getPath", "()Ljava/lang/String;")JAVA_CHECK_RETURN(getPath_methodID);

            jobject oem_directory_object = __env->CallStaticObjectMethod(environment_class, getOemDirectory_methodID)JAVA_CHECK_RETURN(oem_directory_object);

            jstring oem_path_string = static_cast<jstring>(__env->CallObjectMethod(oem_directory_object, getPath_methodID))JAVA_CHECK_RETURN(oem_path_string);

            const char* oem_path = __env->GetStringUTFChars(oem_path_string, 0)JAVA_CHECK_RETURN(oem_path);

            if (strlen(oem_path) > 0)
            {
                oem_dir = oem_path;
            }

            __env->ReleaseStringUTFChars(oem_path_string, oem_path)JAVA_EXCEPTION_RETURN();
        };

        get_fontxml();

        std::string xml_file = oem_dir.empty() ? SYSTEM_ETC "fonts_zawygi.xml" : oem_dir + "/etc/fonts_zawygi.xml";
        ACCESS_XML(xml_file.c_str(), oem_dir.empty() ? SYSTEM_FONTS : oem_dir + "/fonts/", __xmlfiles);
        xml_file = oem_dir.empty() ? SYSTEM_ETC "fonts_myanmar.xml" : oem_dir + "/etc/fonts_myanmar.xml";
        ACCESS_XML(xml_file.c_str(), oem_dir.empty() ? SYSTEM_FONTS : oem_dir + "/fonts/", __xmlfiles);
    }
}
#endif

#if SPECIAL_MACHINE_ANDROID
static void get_fontxml_for_meizu_from_java(JNIEnv* __env, std::unordered_map<std::string, std::string>& __fonts)
{
    if (sdk_ver_ == __ANDROID_API_Q__
        || sdk_ver_ == __ANDROID_API_R__)
    {
        ACCESS_XML(SYSTEM_ETC "fonts_flyme.xml", SYSTEM_FONTS, __fonts);
    }
    else if (sdk_ver_ >= __ANDROID_API_N__ && sdk_ver_ <= __ANDROID_API_P__)
    {
        /*
        Android 9
        boolean isCTSRunning = SystemProperties.getBoolean("persist.sys.cts_Myanmar_state", false);
        if (isCTSRunning) {
            buildSystemFallback("/system/etc/fonts_cts.xml", "/system/fonts/", systemFontMap, systemFallbackMap);
        } else if (BuildExt.isProductInternational()) {
            buildSystemFallback("/system/etc/fonts_inter.xml", "/system/fonts/", systemFontMap, systemFallbackMap);
        } else {
            buildSystemFallback("/system/etc/fonts.xml", "/system/fonts/", systemFontMap, systemFallbackMap);
        }

        Android 7.0/8.1
        static final String FONTS_CONFIG = "fonts.xml";
        static final String FONTS_CTS_CONFIG = "fonts_cts.xml";
        boolean isCTSRunning = SystemProperties.getBoolean("persist.sys.cts_Myanmar_state", false);
        if (isCTSRunning) {
            configFilename = new File(systemFontConfigLocation, FONTS_CTS_CONFIG);
        } else {
            configFilename = new File(systemFontConfigLocation, FONTS_CONFIG);
        }
        */

        char state[92] = {0};

        if (__system_property_get("persist.sys.cts_Myanmar_state", state) > 0)
        {
            if (strcmp(state, "true") == 0)
            {
                ACCESS_XML(SYSTEM_ETC "fonts_cts.xml", SYSTEM_FONTS, __fonts);

                return;
            }
        }

        jboolean result = false;

        if (sdk_ver_ == __ANDROID_API_P__)
        {
            auto get_fontxml = [&](){
                javaExceptionGuard exceptionGuard(__env);

                jclass buildext_class = __env->FindClass("android/os/BuildExt")JAVA_CHECK_RETURN(buildext_class);

                jmethodID isProductInternational_methodID = __env->GetStaticMethodID(buildext_class, "isProductInternational", "()Z")JAVA_CHECK_RETURN(isProductInternational_methodID);

                jboolean isProductInternational = __env->CallStaticBooleanMethod(buildext_class, isProductInternational_methodID)JAVA_EXCEPTION_RETURN();

                result = isProductInternational;
            };

            get_fontxml();
        }

        if (result)
        {
            ACCESS_XML(SYSTEM_ETC "fonts_inter.xml", SYSTEM_FONTS, __fonts);
        }
        else
        {
            ACCESS_XML(SYSTEM_ETC "fonts.xml", SYSTEM_FONTS, __fonts);
        }
    }
}
#endif

static void get_typeface_native_ptrs_by_map_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::set<void*>& __typefaces)
{
    javaExceptionGuard exceptionGuard(__env);

    // FindClass
    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);
    jclass map_clazz = __env->FindClass("java/util/Map")JAVA_CHECK_RETURN(map_clazz);
    jclass set_clazz = __env->FindClass("java/util/Set")JAVA_CHECK_RETURN(set_clazz);
    jclass interator_clazz = __env->FindClass("java/util/Iterator")JAVA_CHECK_RETURN(interator_clazz);
    jclass entry_clazz = __env->FindClass("java/util/Map$Entry")JAVA_CHECK_RETURN(entry_clazz);

    // GetMethodID
    jmethodID entrySet_methodID = __env->GetMethodID(map_clazz, "entrySet", "()Ljava/util/Set;")JAVA_CHECK_RETURN(entrySet_methodID);
    jmethodID iterator_methodID = __env->GetMethodID(set_clazz, "iterator", "()Ljava/util/Iterator;")JAVA_CHECK_RETURN(iterator_methodID);
    jmethodID hasNext_methodID = __env->GetMethodID(interator_clazz, "hasNext", "()Z")JAVA_CHECK_RETURN(hasNext_methodID);
    jmethodID next_methodID = __env->GetMethodID(interator_clazz, "next", "()Ljava/lang/Object;")JAVA_CHECK_RETURN(next_methodID);
    jmethodID getValue_methodID = __env->GetMethodID(entry_clazz, "getValue", "()Ljava/lang/Object;")JAVA_CHECK_RETURN(getValue_methodID);

    // Get*FieldID
    jfieldID native_instance_fieldID = __env->GetFieldID(typeface_clazz, "native_instance", "J")JAVA_CHECK_RETURN(native_instance_fieldID);

    for (auto&& iter : fields)
    {
        LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

        // Get*FieldID
        jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_CONTINUE(fieldID);

        // Get*Field
        jobject field = __env->GetStaticObjectField(typeface_clazz, fieldID)JAVA_CHECK_CONTINUE(field);

        // Call*Method
        jobject set_object = __env->CallObjectMethod(field, entrySet_methodID)JAVA_CHECK_RETURN(set_object);
        jobject iterator_object = __env->CallObjectMethod(set_object, iterator_methodID)JAVA_CHECK_RETURN(iterator_object);
        while (1)
        {
            jboolean hasNext = __env->CallBooleanMethod(iterator_object, hasNext_methodID)JAVA_EXCEPTION_RETURN();

            if (!hasNext)
            {
                break;
            }

            jobject entry_object = __env->CallObjectMethod(iterator_object, next_methodID)JAVA_CHECK_RETURN(entry_object);

            jobject typeface_object = __env->CallObjectMethod(entry_object, getValue_methodID)JAVA_EXCEPTION_RETURN()JAVA_NULLPTR_CONTINUE(typeface_object);

            void* native_instance = reinterpret_cast<void*>(__env->GetLongField(typeface_object, native_instance_fieldID))JAVA_CHECK_RETURN(native_instance);

            __typefaces.emplace(native_instance);

            __env->DeleteLocalRef(typeface_object)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(entry_object)JAVA_EXCEPTION_RETURN();
        }
        __env->DeleteLocalRef(iterator_object)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(set_object)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(field)JAVA_EXCEPTION_RETURN();
    }
}

#if DEBUGGABLE
static void get_font_data_from_java(JNIEnv* __env, std::unordered_map<void*, size_t>& __fontData)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass systemfonts_clazz = __env->FindClass("android/graphics/fonts/SystemFonts")JAVA_CHECK_RETURN(systemfonts_clazz);
    jclass font_clazz = __env->FindClass("android/graphics/fonts/Font")JAVA_CHECK_RETURN(font_clazz);
    jclass set_clazz = __env->FindClass("java/util/Set")JAVA_CHECK_RETURN(set_clazz);
    jclass interator_clazz = __env->FindClass("java/util/Iterator")JAVA_CHECK_RETURN(interator_clazz);

    jmethodID getAvailableFonts_methodID = __env->GetStaticMethodID(systemfonts_clazz, "getAvailableFonts", "()Ljava/util/Set;")JAVA_CHECK_RETURN(getAvailableFonts_methodID);
    jmethodID getBuffer_methodID = __env->GetMethodID(font_clazz, "getBuffer", "()Ljava/nio/ByteBuffer;")JAVA_CHECK_RETURN(getBuffer_methodID);
    jmethodID iterator_methodID = __env->GetMethodID(set_clazz, "iterator", "()Ljava/util/Iterator;")JAVA_CHECK_RETURN(iterator_methodID);
    jmethodID hasNext_methodID = __env->GetMethodID(interator_clazz, "hasNext", "()Z")JAVA_CHECK_RETURN(hasNext_methodID);
    jmethodID next_methodID = __env->GetMethodID(interator_clazz, "next", "()Ljava/lang/Object;")JAVA_CHECK_RETURN(next_methodID);

    jobject set_object = __env->CallStaticObjectMethod(systemfonts_clazz, getAvailableFonts_methodID)JAVA_CHECK_RETURN(set_object);

    jobject iterator_object = __env->CallObjectMethod(set_object, iterator_methodID)JAVA_CHECK_RETURN(iterator_object);

    while (1)
    {
        jboolean hasNext = __env->CallBooleanMethod(iterator_object, hasNext_methodID)JAVA_EXCEPTION_RETURN();
        if (!hasNext)
        {
            break;
        }

        jobject font_object = __env->CallObjectMethod(iterator_object, next_methodID)JAVA_CHECK_RETURN(font_object);

        jobject bytebuffer = __env->CallObjectMethod(font_object, getBuffer_methodID)JAVA_CHECK_RETURN(bytebuffer);

        const void* fontPtr = __env->GetDirectBufferAddress(bytebuffer)JAVA_CHECK_RETURN(fontPtr);
        size_t fontSize = static_cast<size_t>(__env->GetDirectBufferCapacity(bytebuffer))JAVA_EXCEPTION_RETURN()EXPRESSION_RETURN(fontSize, <=, 0, );

        if (!check_maps(fontPtr, fontSize, __fontData))
        {
            LOG("check_maps failed!");
            break;
        }

        __env->DeleteLocalRef(bytebuffer)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(font_object)JAVA_EXCEPTION_RETURN();
    }
}
#endif

static void get_typeface_native_ptrs_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::set<void*>& __typefaces)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);

    jfieldID native_instance_fieldID = __env->GetFieldID(typeface_clazz, "native_instance", "J")JAVA_CHECK_RETURN(native_instance_fieldID);

    for (auto&& iter : fields)
    {
        LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

        jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_RETURN(fieldID);

        jobject field = __env->GetStaticObjectField(typeface_clazz, fieldID)JAVA_CHECK_RETURN(field);

        if (iter.second == "[Landroid/graphics/Typeface;")
        {
            jobjectArray typeface_array = static_cast<jobjectArray>(field)JAVA_CHECK_RETURN(typeface_array);

            jsize array_size = __env->GetArrayLength(typeface_array)JAVA_EXCEPTION_RETURN();

            for (jsize i = 0; i < array_size; ++i)
            {
                jobject typeface_object = __env->GetObjectArrayElement(typeface_array, i)JAVA_CHECK_RETURN(typeface_object);

                void* native_instance = reinterpret_cast<void*>(__env->GetLongField(typeface_object, native_instance_fieldID))JAVA_CHECK_RETURN(native_instance);

                __typefaces.emplace(native_instance);

                __env->DeleteLocalRef(typeface_object)JAVA_EXCEPTION_RETURN();
            }
        }
        else
        {
            void* native_instance = reinterpret_cast<void*>(__env->GetLongField(field, native_instance_fieldID))JAVA_CHECK_RETURN(native_instance);

            __typefaces.emplace(native_instance);
        }

        __env->DeleteLocalRef(field)JAVA_EXCEPTION_RETURN();
    }
}

#if SPECIAL_MACHINE_ANDROID
static void get_fallbackFonts_for_motorola_from_java(JNIEnv* __env, std::unordered_map<std::string, std::string>& __fontFamilies)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass locale_class = __env->FindClass("java/util/Locale")JAVA_CHECK_RETURN(locale_class);

    jmethodID getDefault_methodID = __env->GetStaticMethodID(locale_class, "getDefault", "()Ljava/util/Locale;")JAVA_CHECK_RETURN(getDefault_methodID);
    jobject locale_default = __env->CallStaticObjectMethod(locale_class, getDefault_methodID)JAVA_CHECK_RETURN(locale_default);

    jmethodID toString_methodID = __env->GetMethodID(locale_class, "toString", "()Ljava/lang/String;")JAVA_CHECK_RETURN(toString_methodID);
    jstring locale_string = static_cast<jstring>(__env->CallObjectMethod(locale_default, toString_methodID))JAVA_CHECK_RETURN(locale_string);

    const char* locale = __env->GetStringUTFChars(locale_string, 0)JAVA_CHECK_RETURN(locale_string);

    if (strlen(locale) > 0 && (strcmp(locale, "en_ZG") == 0 || strcmp(locale, "en_EZ") == 0))
    {
        __fontFamilies.emplace("sMyanmarFallbackFonts", "[Landroid/graphics/FontFamily;");
    }
    else
    {
        __fontFamilies.emplace("sZawgyiFallbackFonts", "[Landroid/graphics/FontFamily;");
    }

    __env->ReleaseStringUTFChars(locale_string, locale)JAVA_EXCEPTION_RETURN();
}
#endif

static void get_fontFamily_native_ptrs_by_map_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::set<void*>& __fontFamilies)
{
    javaExceptionGuard exceptionGuard(__env);
    // FindClass
    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);
    jclass fontFamily_class = __env->FindClass("android/graphics/FontFamily")JAVA_CHECK_RETURN(fontFamily_class);
    jclass map_clazz = __env->FindClass("java/util/Map")JAVA_CHECK_RETURN(map_clazz);
    jclass set_clazz = __env->FindClass("java/util/Set")JAVA_CHECK_RETURN(set_clazz);
    jclass interator_clazz = __env->FindClass("java/util/Iterator")JAVA_CHECK_RETURN(interator_clazz);
    jclass entry_clazz = __env->FindClass("java/util/Map$Entry")JAVA_CHECK_RETURN(entry_clazz);

    // GetMethodID
    jmethodID entrySet_methodID = __env->GetMethodID(map_clazz, "entrySet", "()Ljava/util/Set;")JAVA_CHECK_RETURN(entrySet_methodID);
    jmethodID iterator_methodID = __env->GetMethodID(set_clazz, "iterator", "()Ljava/util/Iterator;")JAVA_CHECK_RETURN(iterator_methodID);
    jmethodID hasNext_methodID = __env->GetMethodID(interator_clazz, "hasNext", "()Z")JAVA_CHECK_RETURN(hasNext_methodID);
    jmethodID next_methodID = __env->GetMethodID(interator_clazz, "next", "()Ljava/lang/Object;")JAVA_CHECK_RETURN(next_methodID);
    jmethodID getValue_methodID = __env->GetMethodID(entry_clazz, "getValue", "()Ljava/lang/Object;")JAVA_CHECK_RETURN(getValue_methodID);

    jfieldID mNativePtr_fieldID = __env->GetFieldID(fontFamily_class, "mNativePtr", "J")JAVA_CHECK_RETURN(mNativePtr_fieldID);

    for (auto&& iter : fields)
    {
        LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

        // Get*FieldID
        jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_CONTINUE(fieldID);

        // Get*Field
        jobject field = __env->GetStaticObjectField(typeface_clazz, fieldID)JAVA_CHECK_CONTINUE(field);

        // Call*Method
        jobject set_object = __env->CallObjectMethod(field, entrySet_methodID)JAVA_CHECK_RETURN(set_object);
        jobject iterator_object = __env->CallObjectMethod(set_object, iterator_methodID)JAVA_CHECK_RETURN(iterator_object);

        while (1)
        {
            jboolean hasNext = __env->CallBooleanMethod(iterator_object, hasNext_methodID)JAVA_EXCEPTION_RETURN();
            if (!hasNext)
            {
                break;
            }

            jobject entry_object = __env->CallObjectMethod(iterator_object, next_methodID)JAVA_CHECK_RETURN(entry_object);

            jobjectArray field_array = static_cast<jobjectArray>(__env->CallObjectMethod(entry_object, getValue_methodID))JAVA_EXCEPTION_RETURN()JAVA_NULLPTR_CONTINUE(field_array);

            jsize array_size = __env->GetArrayLength(field_array)JAVA_EXCEPTION_RETURN();

            for (jsize i = 0; i < array_size; ++i)
            {
                jobject fontfamily_object = __env->GetObjectArrayElement(field_array, i)JAVA_CHECK_RETURN(fontfamily_object);

                void* mNativePtr_native = reinterpret_cast<void*>(__env->GetLongField(fontfamily_object, mNativePtr_fieldID))JAVA_CHECK_RETURN(mNativePtr_native);

                __fontFamilies.emplace(mNativePtr_native);

                __env->DeleteLocalRef(fontfamily_object)JAVA_EXCEPTION_RETURN();
            }

            __env->DeleteLocalRef(field_array)JAVA_EXCEPTION_RETURN();
            __env->DeleteLocalRef(entry_object)JAVA_EXCEPTION_RETURN();
        }
        __env->DeleteLocalRef(iterator_object)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(set_object)JAVA_EXCEPTION_RETURN();
        __env->DeleteLocalRef(field)JAVA_EXCEPTION_RETURN();
    }
}

static void get_fontFamily_native_ptrs_from_java(JNIEnv* __env, const std::unordered_map<std::string, std::string>& fields, std::set<void*>& __fontFamilies)
{
    javaExceptionGuard exceptionGuard(__env);

    jclass typeface_clazz = __env->FindClass("android/graphics/Typeface")JAVA_CHECK_RETURN(typeface_clazz);
    jclass fontFamily_class = __env->FindClass("android/graphics/FontFamily")JAVA_CHECK_RETURN(fontFamily_class);
    jfieldID mNativePtr_fieldID = __env->GetFieldID(fontFamily_class, "mNativePtr", "J")JAVA_CHECK_RETURN(mNativePtr_fieldID);

    for (auto&& iter : fields)
    {
        LOG("fields:%s sig:%s", iter.first.c_str(), iter.second.c_str());

        // Get*FieldID
        jfieldID fieldID = __env->GetStaticFieldID(typeface_clazz, iter.first.c_str(), iter.second.c_str())JAVA_CHECK_CONTINUE(fieldID);

        // Get*Field
        jobject field = __env->GetStaticObjectField(typeface_clazz, fieldID)JAVA_CHECK_CONTINUE(field);

        if (iter.second == "[Landroid/graphics/FontFamily;")
        {
            jobjectArray field_array = static_cast<jobjectArray>(field)JAVA_CHECK_RETURN(field_array);

            jsize array_size = __env->GetArrayLength(field_array)JAVA_EXCEPTION_RETURN();

            for (jsize i = 0; i < array_size; ++i)
            {
                jobject fontfamily_object = __env->GetObjectArrayElement(field_array, i)JAVA_CHECK_RETURN(fontfamily_object);

                void* mNativePtr_native = reinterpret_cast<void*>(__env->GetLongField(fontfamily_object, mNativePtr_fieldID));JAVA_CHECK_RETURN(mNativePtr_native);

                __fontFamilies.emplace(mNativePtr_native);

                __env->DeleteLocalRef(fontfamily_object)JAVA_EXCEPTION_RETURN();
            }
        }
        else
        {
            void* mNativePtr_native = reinterpret_cast<void*>(__env->GetLongField(field, mNativePtr_fieldID));JAVA_CHECK_RETURN(mNativePtr_native);

            __fontFamilies.emplace(mNativePtr_native);
        }

        __env->DeleteLocalRef(field)JAVA_EXCEPTION_RETURN();
    }
}

static void get_blacklist_from_java(JNIEnv* __env, jintArray __black_list, std::unordered_set<size_t>& __blacklist)
{
    javaExceptionGuard exceptionGuard(__env);

    if (__black_list != nullptr)
    {
        jint* array = __env->GetIntArrayElements(__black_list, nullptr)JAVA_EXCEPTION_RETURN();

        if (array != nullptr)
        {
            jsize size = __env->GetArrayLength(__black_list)JAVA_EXCEPTION_RETURN();

            for (jsize i = 0; i < size; ++i)
            {
                __blacklist.insert(static_cast<size_t>(array[i]))JAVA_EXCEPTION_RETURN();
                LOG("blacklist:%zu", static_cast<size_t>(array[i]))JAVA_EXCEPTION_RETURN();
            }
        }

        __env->ReleaseIntArrayElements(__black_list, array, 0)JAVA_EXCEPTION_RETURN();
    }
}